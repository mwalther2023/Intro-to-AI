import GAinspector
# import numpy as np
from utils import *
# import matplotlib.pyplot as plt
def randomGenome(length):
    """
    :param length:
    :return: string, random binary digit
    """
    """Your Code Here"""
    # raiseNotDefined()
    genome = ""
    for n in range(length):
        genome += str(random.randint(0,1))
    return genome

def makePopulation(size, length):
    """
    :param size - of population:
    :param length - of genome
    :return: list of length size containing genomes of length length
    """

    """Your Code Here"""

    # raiseNotDefined()
    popList = []
    for n in range(size):
        popList.append(randomGenome(length))
    return popList


def fitness(genome):
    """
    :param genome: 
    :return: the fitness value of a genome
    """
    # raiseNotDefined()
    fitness = 0
    for i in range(len(genome)):
        if genome[i] == "1":
            fitness += 1
    return fitness

def evaluateFitness(population):
    """
    :param population: 
    :return: a pair of values: the average fitness of the population as a whole and the fitness of the best individual in the population.
    """
    # raiseNotDefined()
    bestFitness = 0
    avgFitness = 0
    for i in range(len(population)):
        newFitness = fitness(population[i])
        if newFitness > bestFitness:
            bestFitness = newFitness
        avgFitness += newFitness
    return (avgFitness/len(population), bestFitness)



def crossover(genome1, genome2):
    """
    :param genome1:
    :param genome2:
    :return: two new genomes produced by crossing over the given genomes at a random crossover point.
    """
    # raiseNotDefined()
    crossPt = random.randint(1,len(genome1)-1)
    cross1start = genome1[:crossPt]
    cross2start = genome2[:crossPt]

    cross1end = genome1[crossPt:]
    cross2end = genome2[crossPt:]

    child1 = cross1start + cross2end
    child2 = cross2start + cross1end
    return [child1, child2]

def mutate(genome, mutationRate):
    """
    :param genome:
    :param mutationRate:
    :return: a new mutated version of the given genome.
    """
    # raiseNotDefined()
    
    # print("Chance: "+str(chance))
    for i in range(len(genome)):
        chance = random.random()
        if chance <= mutationRate:
            if genome[i] == '1':
                genome = genome[:i] + "0" + genome[i+1:]
            else:
                genome = genome[:i] + "1" + genome[i+1:]
    return genome
def selectPair(population):
    """

    :param population:
    :return: two genomes from the given population using fitness-proportionate selection.
    This function should use weightedChoice, which is available in the Utils File, as a helper function.
    """
    # raiseNotDefined()
    weights = []
    for n in population:
        weights.append(fitness(n))
    choice1 = weightedChoice(population,weights)
    i = population.index(choice1)
    # print(choice1)
    # print(i)
    newPop = population[:i] + population[i+1:]
    newWeights = weights[:i] + weights[i+1:]
    # for p in population:
    #     if p is not choice1:
    #         newPop.append(p)
    #         weights.append(fitness(p))
    # print(newPop)
    # choice2 = weightedChoice(newPop,newWeights)
    choice2 = weightedChoice(population,weights)
    return (choice1, choice2)
xPts = []
yPts = []
xList = []
yList = []
def runGA(populationSize, crossoverRate, mutationRate, logFile=""):
    """

    :param populationSize: :param crossoverRate: :param mutationRate: :param logFile: :return: xt file in which to
    store the data generated by the GA, for plotting purposes. When the GA terminates, this function should return
    the generation at which the string of all ones was found.is the main GA program, which takes the population size,
    crossover rate (pc), and mutation rate (pm) as parameters. The optional logFile parameter is a string specifying
    the name of a te
    """
    # raiseNotDefined()
    if logFile != "":
            # print("File output")
            file = open(logFile,'w')
    print("Population size: "+ str(populationSize))
    genomeLength = 20
    print("Genome length: " + str(genomeLength))
    population = makePopulation(populationSize,genomeLength)
    global xPts
    global yPts
    global xList
    global yList
    for i in range(1000):
        (avgFit, bestFit) = evaluateFitness(population)
        print("Generation {}: \taverage fitness {}, best fitness {}".format(i,avgFit,bestFit))
        xPts.append(i)
        yPts.append(avgFit)
        if bestFit == genomeLength:
            if logFile != "":
                file.write("{}\t{}\t{}\n".format(i,avgFit,bestFit))
            xList.append(xPts)
            yList.append(yPts)
            xPts = []
            yPts = []
            return i
            # break
        crossList = []
        childrenList = []
        # for p in range(0,len(population),2):
        #     cross = random.random()
        #     if cross <= crossoverRate:
        #         crossList.append(p)                
        #         (par1, par2) = selectPair(population)
        #         (child1, child2) = crossover(par1, par2)
        #         child1 = mutate(child1, mutationRate)
        #         child2 = mutate(child2, mutationRate)
        #         childrenList.append(child1)
        #         childrenList.append(child2)
        #     else:
        #         (par1, par2) = selectPair(population)
        #         childrenList.append(par1)
        #         childrenList.append(par2)
        for p in range(0,len(population),2):
            (par1, par2) = selectPair(population)
            cross = random.random()
            if cross <= crossoverRate:
                # print("Picking parents")
                # (par1, par2) = selectPair(population)
                # print("p: "+str(par1))
                # print("Crossover")
                (child1, child2) = crossover(par1, par2)
                # print("p: "+str(child1))
                child1 = mutate(child1, mutationRate)
                child2 = mutate(child2, mutationRate)
                childrenList.append(child1)
                childrenList.append(child2)
            else:
                # (par1, par2) = selectPair(population)
                child1 = mutate(par1, mutationRate)
                child2 = mutate(par2, mutationRate)
                childrenList.append(child1)
                childrenList.append(child2)
        # print(len(population))
        population = childrenList
        if logFile != "":
            file.write("{}\t{}\t{}\n".format(i,avgFit,bestFit))
    xList.append(xPts)
    yList.append(yPts)
    xPts = []
    yPts = []
    return None



if __name__ == '__main__':
    #Testing Code
    print("Test Suite")
    GAinspector.inspectFunction(randomGenome)
    GAinspector.inspectFunction(makePopulation)
    GAinspector.inspectFunction(fitness)
    GAinspector.inspectFunction(evaluateFitness)
    GAinspector.inspectFunction(crossover)
    GAinspector.inspectFunction(mutate)
    GAinspector.inspectFunction(selectPair)

    # runGA(100, 0.7, 0.001, "run1.txt")

    genList = []
    minGen = 999
    maxGen = 0
    for n in range(50):
        gen = runGA(100, 0.7, 0.01, "report1.txt")
        if gen is not None:
            genList.append(gen)
            if minGen > gen:
                minGen = gen
            if maxGen < gen:
                maxGen = gen
    # rList = []
    # for i in range(5):
    #     r = random.randint(0,len(xList))
    #     while r in rList:
    #         r = random.randint(0,len(xList))
    #     rList.append(r)
    # for i in rList:
    #     plt.plot(xList[i],yList[i])
    # plt.xlabel('Generation')
    # plt.ylabel('Average Fitness')
    sumGen = 0
    for i in genList:
        sumGen += i
    print("Avg Gen: " + str(round(sumGen/len(genList),4)))
    print("Max Gen: " + str(maxGen))
    print("Min Gen: " + str(minGen))
    # plt.show()
